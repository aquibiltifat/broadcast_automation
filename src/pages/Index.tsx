import { useState, useEffect } from 'react';
import { Header } from '@/components/Header';
import { StatsBar } from '@/components/StatsBar';
import { BroadcastCard } from '@/components/BroadcastCard';
import { CommonMembersPanel } from '@/components/CommonMembersPanel';
import { CreateListDialog } from '@/components/CreateListDialog';
import { SyncStatus, useWebSocket } from '@/components/SyncStatus';
import { findCommonMembers } from '@/data/mockData';
import { BroadcastList, AutomationLog, Contact } from '@/types/broadcast';
import { useToast } from '@/hooks/use-toast';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { Button } from '@/components/ui/button';
import { List, Sparkles, Plus, Trash2, RefreshCw, Zap, Users } from 'lucide-react';
import {
  loadLists,
  saveLists,
  loadLogs,
  saveLogs,
  addList,
  deleteList,
  generateId
} from '@/services/storage';
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";

// Backend configuration
const PYTHON_BACKEND_URL = 'http://localhost:3002';
const WS_URL = 'ws://localhost:3002/ws';

const Index = () => {
  const [lists, setLists] = useState<BroadcastList[]>([]);
  const [selectedLists, setSelectedLists] = useState<string[]>([]);
  const [logs, setLogs] = useState<AutomationLog[]>([]);
  const [createDialogOpen, setCreateDialogOpen] = useState(false);
  const [deleteDialogOpen, setDeleteDialogOpen] = useState(false);
  const [listToDelete, setListToDelete] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [isSyncing, setIsSyncing] = useState(false);
  const [deviceName, setDeviceName] = useState<string>('');
  const { toast } = useToast();

  // WebSocket connection for real-time updates
  const { isConnected, lastSync, clearLastSync } = useWebSocket(WS_URL);

  // Load data on mount
  useEffect(() => {
    loadData();
  }, []);

  // Auto-refresh when sync event received
  useEffect(() => {
    if (lastSync && (lastSync.type === 'sync' || lastSync.type === 'data_change')) {
      console.log('Received sync event, refreshing data...');
      if (lastSync.device_id) {
        setDeviceName(lastSync.device_id);
      }
      loadData();

      toast({
        title: "ðŸ“± Data Synced!",
        description: `${lastSync.device_id} synced ${lastSync.lists_count} lists`,
      });
    }
  }, [lastSync]);

  const loadData = async () => {
    setIsLoading(true);

    // Try to load from Python backend
    try {
      const response = await fetch(`${PYTHON_BACKEND_URL}/api/lists`);
      if (response.ok) {
        const data = await response.json();
        if (data.success && data.data) {
          const backendLists: BroadcastList[] = data.data.map((list: any) => ({
            id: list.id,
            name: list.name,
            members: list.members || [],
            createdAt: new Date(list.created_at || list.createdAt || Date.now()),
            isAutoGenerated: list.is_auto_generated || list.isAutoGenerated || false,
          }));
          setLists(backendLists);
          setSelectedLists(backendLists.filter(l => !l.isAutoGenerated).map(l => l.id));
          saveLists(backendLists);
          setIsLoading(false);
          return;
        }
      }
    } catch (error) {
      console.log('Could not fetch from Python backend, using localStorage');
    }

    // Fallback to localStorage
    const storedLists = loadLists();
    const storedLogs = loadLogs();
    setLists(storedLists);
    setLogs(storedLogs);
    setSelectedLists(storedLists.filter(l => !l.isAutoGenerated).map(l => l.id));
    setIsLoading(false);
  };

  const handleSyncFromBackend = async () => {
    setIsSyncing(true);
    try {
      const response = await fetch(`${PYTHON_BACKEND_URL}/api/lists`);
      if (response.ok) {
        const data = await response.json();
        if (data.success && data.data) {
          const backendLists: BroadcastList[] = data.data.map((list: any) => ({
            id: list.id,
            name: list.name,
            members: list.members || [],
            createdAt: new Date(list.created_at || list.createdAt || Date.now()),
            isAutoGenerated: list.is_auto_generated || list.isAutoGenerated || false,
          }));
          setLists(backendLists);
          setSelectedLists(backendLists.filter(l => !l.isAutoGenerated).map(l => l.id));
          saveLists(backendLists);

          toast({
            title: "âœ“ Synced!",
            description: `Loaded ${backendLists.length} lists from backend`,
          });
        } else {
          toast({
            title: "No data",
            description: "No lists found. Start extraction on Android app first.",
          });
        }
      } else {
        throw new Error('Backend not available');
      }
    } catch (error) {
      toast({
        title: "Sync failed",
        description: "Could not connect to Python backend.",
        variant: "destructive",
      });
    }
    setIsSyncing(false);
  };

  const selectedBroadcasts = lists.filter(l => selectedLists.includes(l.id) && !l.isAutoGenerated);

  // Check for auto-generated common members list first
  const autoGeneratedCommonList = lists.find(l =>
    l.isAutoGenerated && (l.name.includes('Common Members') || l.name.includes('â­'))
  );

  // Use auto-generated list members if available, otherwise compute from selection
  const commonMembers = autoGeneratedCommonList
    ? autoGeneratedCommonList.members
    : findCommonMembers(selectedBroadcasts);

  const totalMembers = lists
    .filter(l => !l.isAutoGenerated)
    .reduce((sum, l) => sum + l.members.length, 0);

  const handleSelectList = (listId: string) => {
    setSelectedLists(prev =>
      prev.includes(listId)
        ? prev.filter(id => id !== listId)
        : [...prev, listId]
    );
  };

  const handleCreateList = (name: string, contacts: Contact[]) => {
    const newList = addList(name, contacts);
    setLists(prev => [...prev, newList]);
    setSelectedLists(prev => [...prev, newList.id]);

    const newLog: AutomationLog = {
      id: generateId('log'),
      timestamp: new Date(),
      action: `Created list "${name}"`,
      status: 'success',
      details: `New broadcast list with ${contacts.length} contacts`,
    };
    const updatedLogs = [newLog, ...logs];
    setLogs(updatedLogs);
    saveLogs(updatedLogs);

    toast({
      title: "List created!",
      description: `"${name}" with ${contacts.length} contacts`,
    });
  };

  const handleDeleteRequest = (listId: string) => {
    setListToDelete(listId);
    setDeleteDialogOpen(true);
  };

  const handleDeleteConfirm = () => {
    if (!listToDelete) return;

    const listName = lists.find(l => l.id === listToDelete)?.name || 'List';
    const updatedLists = deleteList(listToDelete);
    setLists(updatedLists);
    setSelectedLists(prev => prev.filter(id => id !== listToDelete));

    const newLog: AutomationLog = {
      id: generateId('log'),
      timestamp: new Date(),
      action: `Deleted list "${listName}"`,
      status: 'success',
    };
    const updatedLogs = [newLog, ...logs];
    setLogs(updatedLogs);
    saveLogs(updatedLogs);

    toast({
      title: "List deleted",
      description: `"${listName}" has been removed`,
    });

    setListToDelete(null);
    setDeleteDialogOpen(false);
  };

  const handleCreateFromCommon = () => {
    if (commonMembers.length === 0) {
      toast({
        title: "No common members",
        description: "Select lists with common members to create a new list.",
        variant: "destructive",
      });
      return;
    }

    const newList: BroadcastList = {
      id: generateId('auto'),
      name: 'Common Members List',
      members: commonMembers,
      createdAt: new Date(),
      isAutoGenerated: true,
    };

    const updatedLists = [...lists, newList];
    setLists(updatedLists);
    saveLists(updatedLists);
    setSelectedLists(prev => [...prev, newList.id]);

    const newLog: AutomationLog = {
      id: generateId('log'),
      timestamp: new Date(),
      action: 'Created new broadcast list',
      status: 'success',
      details: `Created "Common Members List" with ${commonMembers.length} contacts`,
    };
    const updatedLogs = [newLog, ...logs];
    setLogs(updatedLogs);
    saveLogs(updatedLogs);

    toast({
      title: "List created successfully!",
      description: `New broadcast list with ${commonMembers.length} common members.`,
    });
  };

  if (isLoading) {
    return (
      <div className="min-h-screen bg-background dark flex items-center justify-center">
        <div className="flex flex-col items-center gap-4">
          <div className="h-12 w-12 rounded-2xl bg-gradient-to-br from-emerald-400 to-emerald-600 flex items-center justify-center animate-pulse">
            <Zap className="h-6 w-6 text-white" />
          </div>
          <p className="text-muted-foreground">Loading...</p>
        </div>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-gradient-to-br from-[#0a0a0f] via-[#0f0f1a] to-[#1a1025]">
      <Header
        isConnected={isConnected}
        deviceName={deviceName}
      />

      <main className="container py-6 space-y-6 px-4">
        {/* Stats Cards */}
        <div className="grid grid-cols-3 gap-4">
          <div className="stats-card">
            <div className="flex items-center gap-3">
              <div className="h-10 w-10 rounded-xl bg-emerald-500/20 flex items-center justify-center">
                <List className="h-5 w-5 text-emerald-400" />
              </div>
              <div>
                <p className="text-2xl font-bold text-white">{lists.length}</p>
                <p className="text-xs text-muted-foreground">Lists</p>
              </div>
            </div>
          </div>

          <div className="stats-card">
            <div className="flex items-center gap-3">
              <div className="h-10 w-10 rounded-xl bg-purple-500/20 flex items-center justify-center">
                <Users className="h-5 w-5 text-purple-400" />
              </div>
              <div>
                <p className="text-2xl font-bold text-white">{totalMembers}</p>
                <p className="text-xs text-muted-foreground">Members</p>
              </div>
            </div>
          </div>

          <div className="stats-card">
            <div className="flex items-center gap-3">
              <div className="h-10 w-10 rounded-xl bg-yellow-500/20 flex items-center justify-center">
                <Sparkles className="h-5 w-5 text-yellow-400" />
              </div>
              <div>
                <p className="text-2xl font-bold text-white">{commonMembers.length}</p>
                <p className="text-xs text-muted-foreground">Common</p>
              </div>
            </div>
          </div>
        </div>

        <Tabs defaultValue="lists" className="space-y-4">
          <div className="flex items-center justify-between flex-wrap gap-3">
            <TabsList className="glass-card">
              <TabsTrigger value="lists" className="gap-2 data-[state=active]:bg-emerald-500/20">
                <List className="h-4 w-4" />
                <span>Lists</span>
              </TabsTrigger>
              <TabsTrigger value="common" className="gap-2 data-[state=active]:bg-purple-500/20">
                <Sparkles className="h-4 w-4" />
                <span>Common</span>
              </TabsTrigger>
            </TabsList>

            <div className="flex gap-2">
              <Button
                onClick={handleSyncFromBackend}
                variant="outline"
                disabled={isSyncing}
                className="border-emerald-500/30 hover:border-emerald-500/50 hover:bg-emerald-500/10"
              >
                <RefreshCw className={`h-4 w-4 mr-2 ${isSyncing ? 'animate-spin' : ''}`} />
                {isSyncing ? 'Syncing...' : 'Refresh'}
              </Button>
              <Button
                onClick={() => setCreateDialogOpen(true)}
                className="bg-gradient-to-r from-emerald-500 to-emerald-600 hover:from-emerald-600 hover:to-emerald-700"
              >
                <Plus className="h-4 w-4 mr-2" />
                New List
              </Button>
            </div>
          </div>

          <TabsContent value="lists" className="space-y-4 animate-fade-in">
            {lists.length > 0 ? (
              <div className="grid gap-4 sm:grid-cols-2 lg:grid-cols-3">
                {lists.map((list) => (
                  <div key={list.id} className="relative group">
                    <BroadcastCard
                      list={list}
                      isSelected={selectedLists.includes(list.id)}
                      onSelect={() => handleSelectList(list.id)}
                    />
                    <Button
                      variant="destructive"
                      size="icon"
                      className="absolute top-2 right-2 h-8 w-8 opacity-0 group-hover:opacity-100 transition-opacity"
                      onClick={(e) => {
                        e.stopPropagation();
                        handleDeleteRequest(list.id);
                      }}
                    >
                      <Trash2 className="h-4 w-4" />
                    </Button>
                  </div>
                ))}
              </div>
            ) : (
              <div className="glass-card text-center py-16">
                <div className="h-16 w-16 rounded-2xl bg-gradient-to-br from-emerald-400/20 to-purple-400/20 flex items-center justify-center mx-auto mb-4">
                  <List className="h-8 w-8 text-emerald-400" />
                </div>
                <h3 className="text-lg font-semibold text-white mb-2">No Broadcast Lists Yet</h3>
                <p className="text-sm text-muted-foreground mb-6 max-w-sm mx-auto">
                  Start the auto-extraction on your Android app or create a list manually
                </p>
                <div className="flex gap-3 justify-center">
                  <Button
                    variant="outline"
                    onClick={handleSyncFromBackend}
                    className="border-emerald-500/30"
                  >
                    <RefreshCw className="h-4 w-4 mr-2" />
                    Check for Data
                  </Button>
                  <Button
                    onClick={() => setCreateDialogOpen(true)}
                    className="bg-gradient-to-r from-emerald-500 to-emerald-600"
                  >
                    <Plus className="h-4 w-4 mr-2" />
                    Create Manually
                  </Button>
                </div>
              </div>
            )}
          </TabsContent>

          <TabsContent value="common" className="animate-fade-in">
            <CommonMembersPanel
              members={commonMembers}
              onCreateList={handleCreateFromCommon}
            />
          </TabsContent>
        </Tabs>
      </main>

      {/* Real-time Sync Notification */}
      <SyncStatus
        isConnected={isConnected}
        lastSync={lastSync}
        onDismiss={clearLastSync}
      />

      {/* Create List Dialog */}
      <CreateListDialog
        open={createDialogOpen}
        onOpenChange={setCreateDialogOpen}
        onCreateList={handleCreateList}
        existingNames={lists.map(l => l.name)}
      />

      {/* Delete Confirmation Dialog */}
      <AlertDialog open={deleteDialogOpen} onOpenChange={setDeleteDialogOpen}>
        <AlertDialogContent className="glass-card border-red-500/20">
          <AlertDialogHeader>
            <AlertDialogTitle>Delete List?</AlertDialogTitle>
            <AlertDialogDescription>
              This action cannot be undone. This will permanently delete the
              broadcast list "{lists.find(l => l.id === listToDelete)?.name}".
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel onClick={() => setListToDelete(null)}>
              Cancel
            </AlertDialogCancel>
            <AlertDialogAction
              onClick={handleDeleteConfirm}
              className="bg-destructive text-destructive-foreground hover:bg-destructive/90"
            >
              Delete
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </div>
  );
};

export default Index;
